/* 
 * rsatools, a set of cryptanalysis tools against RSA
 * Copyright (C) 2022 A. Russon
 */

#include "rsa.h"

/* 
 * An alternative to Wiener's attack using a 2-dimensional lattice.
 * We have ed = 1 + k*phi(n)
 * With a small d, then e is of the same size of n and phi(n),
 * so the integer k is of the same size of d.
 * phi(n) is unknown but is very close to n: phi(n) = n - (p+q) + 1,
 * with p+q around sqrt(n) so we have:
 *     ed - kn = 1 + k*phi(n) - kn
 *             = 1 + k*(1 - (p+q))
 *             = O(d*sqrt(n))
 * Now, consider the 2-dimensional lattice given by the following basis matrix:
 *     [ e sqrt(n) ]
 *     [ n       0 ]
 * The vector (ed - kn, d*sqrt(n)) belongs to the lattice generated by the rows
 * of the matrix. Each component of this vector is around O(d*sqrt(n)), which
 * is much smaller than e or n so it is a short vector of the lattice.
 * Of course, one condition is that d is short, and in particular it must be
 * shorter than n^(1/4) which is close to the limit for the Wiener attack.
 * 
 * To find the short vector, we apply Gauss reduction's algorithm.
 * We recover d and reconstruct the prime factors.
 */

/*
 * Compute the smallest vector (u1, u2) and second smallest
 * vector (v1, v2) of the lattice generated by (a, b) and (c, d).
 */
void gauss_reduction(GEN a, GEN b, GEN c, GEN d,
                     GEN *u1, GEN *u2, GEN *v1, GEN *v2) {
  GEN m, u_norm, v_norm, r1, r2;
  pari_sp av = avma;
  *u1 = a;
  *u2 = b;
  *v1 = c;
  *v2 = d;
  while (TRUE) {
    m = gadd(gmul(*u1, *v1), gmul(*u2, *v2));
    u_norm = gadd(gsqr(*u1), gsqr(*u2));
    m = gdivent(m, u_norm);
    r1 = gsub(*v1, gmul(m,*u1));
    r2 = gsub(*v2, gmul(m,*u2));
    u_norm = gadd(gsqr(*u1), gsqr(*u2));
    v_norm = gadd(gsqr(r1), gsqr(r2));
    if (gcmp(v_norm, u_norm) == 1) {
      *v1 = r1;
      *v2 = r2;
      break;
    }
    *v1 = *u1;
    *v2 = *u2;
    *u1 = r1;
    *u2 = r2;
    if (gc_needed(av, 1)) {
      gerepileall(av, 4, u1, u2, v1, v2);
    }
  }

  /* Garbage cleaning */
  gerepileall(av, 4, u1, u2, v1, v2);
}


/*
 * Find the private exponent in the reduced lattice,
 * and reconstruct the prime factors.
 * No garbage cleaning: must be done by the calling function.
 */
int find_d_lattice(GEN u1, GEN u2, GEN n, GEN e, GEN s, GEN *p, GEN *q, GEN *d) {
  GEN k, p_plus_q;
  int found = FALSE;

  /* u2 is expected to be equal to |d*sqrti(n)| */
  *d = gdivexact(u2, s);
  
  /* We also use the first row to find p + q */
  if (signe(*d) == 1) {
    /* u1 = ed - kn    */
    /* u2 = d*sqrti(n) */
    k = gdivexact(gsub(gmul(e, *d), u1), n);
    p_plus_q = gsub(gen_1, gdivexact(gsub(u1, gen_1), k));
  }
  else {
    /* u1 = kn - ed     */
    /* u2 = -d*sqrti(n) */
    *d = gneg(*d);
    k = gdivexact(gadd(u1, gmul(e, *d)), n);
    p_plus_q = gadd(gen_1, gdivexact(gadd(u1, gen_1), k));
  }

  /* With p + q and p*q known, we find p and q */
  *q = gsub(gsqr(p_plus_q), gmulgs(n,4)); /* (p-q)^2 */
  if (Z_issquareall(*q, q)) {
    *p = gadd(p_plus_q, *q);
    *p = shifti(*p, -1L);
    *q = gsub(p_plus_q, *p);
    if (gcmp(gmul(*p, *q), n) == 0) {
      found = TRUE;
    }
  }
  
  return found;
}

int factor_small_d(GEN n, GEN e, GEN *d, GEN *p, GEN *q) {
  int found = FALSE;
  GEN s, u1, u2, v1, v2;
  pari_sp av = avma;

  s = sqrti(n);
  gauss_reduction(e, s, n, gen_0, &u1, &u2, &v1, &v2);
  
  /* Look for d using the first vector, then the next */
  found = find_d_lattice(u1, u2, n, e, s, p, q, d);
  if (found == FALSE) {
    found = find_d_lattice(v1, v2, n, e, s, p, q, d);
  }

  /* Garbage cleaning */
  if (found) {
    gerepileall(av, 3, p, q, d);
  }
  else {
    avma = av;
  }
  return found;
}